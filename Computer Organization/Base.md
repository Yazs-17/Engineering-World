# 硬件结构

## CPU是如何执行程序的？
### 图灵机
### 冯诺依曼模型
1. 运算器、控制器、存储器、输入设备、输出设备
### 基础知识
1. 计算机存储数据的基本单位是字节，
2. 内存，存储区域线性（数组），每个字节对应一个内存地址
3. 中央处理器（CPU），CPU内部组件==寄存器==、==控制单元==和==逻辑运算单元==等
4. 总线，用于CPU和内存以及其他设备之间的通信（地址总线、数据总线、控制总线）
5. 线路位宽表示**数据总线一次能传输的位数**，CPU位宽表示**处理器一次能处理的数据位数**
6. 简单讲讲一个程序执行过程：一个程序执行的时候，CPU会根据程序计数器里的内存地址，从内存里面把需要执行的指令读到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令
7. CPU从指令计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为**CPU的指令周期**
8. 指令、指令的类型、指令的执行速度
   - 指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU通过解析机器码来知道指令内容
   - 不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码
   - a = 1 + 1 一共有四步

### 存储器的层次结构

### CPU的一系列特性

CPU - CPU Cache - 内存

CPU Cache  = many Cache Lines 


缓存一致性，讲解，如何执行任务的？

### 软中断

中断处理程序的下半部，内核出发，通常是耗时比较长的任务，特点是延迟执行

# 操作系统结构

### 内核
作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件细节

###### 内核能力
1. 管理进程、线程，进程调度，决定哪个使用CPU
2. 管理内存，决定内存的分配和回收
3. 管理硬件设备，硬件通信能力
4. 提供系统调用，用户程序与操作系统之间的接口

###### 内核工作空间
内存分为：
1. 内核空间（权限高，内核态）
2. 用户空间（权限低，用户态）
应用程序通过系统调用进入内核空间提权（里面包含两个中断）

### Linux
- 多任务，MultiTask
- SMP，对称多处理
- ELF，可执行文件链接格式
- Monolithic Kernel， 宏内核

### Windows
- 混合型内核 - 宏内核 + 微内核
- 可执行文件格式为 PE

# 内存管理

### 虚拟内存

###### 1. 基本介绍
- 每个进程只需要操作自己的虚拟内存地址就行，不用管物理地址
- 操作系统会提供一种机制，将不同进程的虚拟地址和不用内存的物理地址映射起来

我们在程序所使用的内存地址叫做虚拟内存地址，
实际存在硬件里的空间地址叫做物理内存地址
###### 2. 内存分段和内存分页
- **内存分段**：段选择因子和段内偏移量，产生连续的内存空间
	- **内部内存碎片**：内存交换
- **内存分页**
	- 解决外部内存碎片和内存叫交换效率低
	- 一页固定大小
	- 页表映射虚拟地址和物理地址

###### 3. 段页式内存管理
	TODO


### 内存满了会发生什么？

###### 1. 在4GB物理内存机器上申请8G内存会怎样？
- 32位机器，一般失败，`cannot allocate memory`
- 64位机器，看`overcommit_memory`参数（linux）
- swap，TODO
###### 2. Swap机制的作用


### 如何避免预读失败和缓存污染的问题？

**是什么**
1. 程序在访问内存或磁盘数据时，往往是“局部性原理”的，所以系统会提前加载（预读）相邻的数据块
```
程序访问Ap[0], 预读A[1],A[2]以减少I/O时间
程序可能没有访问数据，导致白白浪费内存或I/O带宽
这就是预读失败
```
2. 无用或低频访问的数据占据了缓存空间，把真正常用的数据挤出去了
```
访问A[0...63] // 高频
访问B[0...4095] // 一次性读取一大块，把A挤掉
导致访问A时又要重新从内存加载，性能反而下降
这就是污染缓存
```

**怎么办**

1. Linux和MySQL的缓存
2. 传统LRU
3. 预读失败怎么办
4. 缓存污染怎么办





# 进程管理


# 调度算法

### 进程调度（CPU调度算法）

> 当CPU空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配CPU

Timing，当进程：
1. 运行到等待
2. 运行到就绪
3. 等待到就绪
4. 运行到终止
非抢占式：1，4； 抢占式：2，3；

> 非抢占式，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把CPU让给其他进程
> 抢占式调度，进程正在运行时，可以被打断，使其把CPU让给其他进程


### 内存页面置换算法


### 磁盘调度算法

### 


# 文件系统

1. 负责管理持久数据的子系统（负责把用户的文件存到磁盘中去）
2. 文件系统的基本数据单位是==文件==

### 基本组成


> 什么叫做持久化，能存在硬盘里的就叫持久化


### 虚拟文件系统


### TODO

文件的使用

文件的存储（连续，非连续，Unix）

管理学知识

目录存储

软链接和硬链接

文件I/O

# 设备管理

### 前言
当设备输入键盘字符，==键盘控制器==就会产生扫描码数据，
并将其缓冲在键盘控制器的==寄存器==中，
接着键盘控制器通过==总线==给CPU发送==中断请求==

CPU收到中断请求之后，
操作系统会保存被中断进程的CPU上下文，
然后调用键盘的==中断处理程序==

键盘的==中断处理程序==是在键盘驱动程序初始化的时候注册的
则其功能就是从键盘控制器的寄存器的缓冲区读取扫描码
再根据扫描码找到用户在键盘中输入的字符，

若字符是显示字符，
就会把扫描码翻译为对应显示字符的ASCII码

得到显示字符的ASCII码之后，
会把ASCII码放到「读缓冲区队列」
接下来就是把显示字符显示到屏幕中

显示设备的驱动程序
会定时从「读缓冲队列」读取数据到「写缓冲队列」
最后把「写缓冲队列」里的一个个字符
写入到显示设备的控制器的寄存器的数据缓冲区
最后将这些数据显示在屏幕里

显示出结果后，
恢复被中断进程的上下文


### 设备控制器
用途：屏蔽设备之间的差异
### I/O控制程序

### 设备驱动程序

注意，现在才到设备驱动程序


# 网络系统

### 导言

>文件传输的技术实现方案？

### 什么是零拷贝
基于PageCache

优化磁盘读写速度的技术
或者，提高文件传输的性能。

通过一次系统调用（sendfile方法）
合并了磁盘读取和网络发送两个操作
降低了上下文切换次数（kafka和Nginx都有具体实现）

此外，零拷贝技术不允许进程对文件内容进一步加工

### TODO





DMA， mmap+write，sendfile， pageCache

### I/O多路复用

### 什么是一致性哈希
分配请求，一致性哈希算法，虚拟节点，均衡度

# Linux 命令

